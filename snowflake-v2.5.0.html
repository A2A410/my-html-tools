<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Snowflake Volunteer v2.5.0</title>
<style>
:root{
--bg:#0d0d0f;--bg2:#141416;--bg3:#1c1c1f;--bg4:#252528;
--border:#2e2e33;--accent:#7d4698;--accent2:#a78bfa;
--ok:#4ade80;--err:#f87171;--warn:#fb923c;--info:#60a5fa;
--txt:#c9d1d9;--txt2:#8b949e;--txt3:#484f58;
--r:10px;--mono:'JetBrains Mono',monospace;
}
*{margin:0;padding:0;box-sizing:border-box}
body{background:var(--bg);color:var(--txt);font-family:system-ui,sans-serif;min-height:100dvh;display:flex;flex-direction:column}
@media(min-width:600px){body{max-width:430px;margin:0 auto;border-left:1px solid var(--border);border-right:1px solid var(--border)}}
#topbar{display:flex;align-items:center;gap:8px;padding:10px 12px;background:var(--bg2);border-bottom:1px solid var(--border)}
.logo{font-size:14px;font-weight:700;color:var(--accent2);letter-spacing:.4px}
.ver{font-size:10px;color:var(--txt3);background:var(--bg4);padding:2px 7px;border-radius:12px}
.spacer{flex:1}
.tbtn{background:none;border:1px solid var(--border);color:var(--txt2);border-radius:var(--r);padding:5px 11px;font-size:11px;cursor:pointer;transition:.15s}
.tbtn:hover{background:var(--bg4);color:var(--txt);border-color:var(--accent)}
#scroll{flex:1;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
::-webkit-scrollbar{width:4px}::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.card{background:var(--bg2);border:1px solid var(--border);border-radius:var(--r);overflow:hidden}
.card-hdr{display:flex;align-items:center;gap:6px;padding:10px 12px;border-bottom:1px solid var(--border);font-size:11px;font-weight:600;color:var(--txt2)}
.dot{width:8px;height:8px;border-radius:50%;background:var(--bg4);flex-shrink:0;transition:.4s}
.dot.ok{background:var(--ok);box-shadow:0 0 6px var(--ok)}
.dot.warn{background:var(--warn);box-shadow:0 0 6px var(--warn)}
.dot.err{background:var(--err);box-shadow:0 0 5px var(--err)}
.card-body{padding:14px 12px}
/* master switch */
.mrow{display:flex;align-items:center;gap:10px;margin-bottom:10px}
.mlbl{flex:1}.mlbl h3{font-size:15px;font-weight:600;margin-bottom:2px}.mlbl p{font-size:11px;color:var(--txt2)}
.toggle{position:relative;width:52px;height:28px;flex-shrink:0}
.toggle input{opacity:0;width:0;height:0}
.tsl{position:absolute;cursor:pointer;inset:0;background:var(--bg4);border-radius:28px;border:2px solid var(--border);transition:.25s}
.tsl:before{content:'';position:absolute;width:20px;height:20px;left:2px;top:2px;background:var(--txt2);border-radius:50%;transition:.25s}
input:checked+.tsl{background:var(--accent);border-color:var(--accent)}
input:checked+.tsl:before{transform:translateX(24px);background:#fff}
/* status pill */
.pill{display:inline-flex;align-items:center;gap:5px;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:600;margin-top:6px;transition:.3s}
.p-off{background:rgba(248,113,113,.12);color:var(--err)}
.p-wait{background:rgba(251,146,60,.12);color:var(--warn)}
.p-on{background:rgba(74,222,128,.12);color:var(--ok)}
.p-err{background:rgba(248,113,113,.2);color:var(--err)}
.pdot{width:6px;height:6px;border-radius:50%;background:currentColor;flex-shrink:0}
.p-on .pdot,.p-wait .pdot{animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.25}}
/* status desc */
#statusdesc-ui{font-size:11px;color:var(--txt2);margin-top:4px;min-height:16px;transition:.2s}
#statusdesc-ui.error{color:var(--err)}
/* retry btn */
#retry-btn{display:none;margin-top:8px;background:var(--warn);color:#000;border:none;border-radius:6px;padding:6px 14px;font-size:11px;font-weight:700;cursor:pointer}
#retry-btn:active{transform:scale(.96)}
/* uptime bar */
#ubar{height:3px;background:var(--bg4);border-radius:2px;margin-top:10px;overflow:hidden}
#ufill{height:100%;width:0%;background:var(--accent);transition:width 1s linear;border-radius:2px}
/* stats */
.stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.stat{background:var(--bg3);border-radius:8px;padding:12px}
.slbl{font-size:10px;color:var(--txt2);text-transform:uppercase;letter-spacing:.5px;margin-bottom:4px}
.sval{font-size:22px;font-weight:700;color:var(--txt);transition:.3s}
.ssub{font-size:10px;color:var(--txt3);margin-top:2px}
/* log */
.logbox{background:var(--bg);padding:8px;font-family:var(--mono);font-size:10.5px;max-height:240px;overflow-y:auto}
/* log tabs */
.ltabs{display:flex;border-bottom:1px solid var(--border);flex-shrink:0}
.ltab{flex:1;padding:5px 0;font-size:10px;font-weight:700;text-align:center;cursor:pointer;color:var(--txt3);background:none;border:none;border-bottom:2px solid transparent;letter-spacing:.5px;text-transform:uppercase;transition:.15s}
.ltab:hover{color:var(--txt2)}
.ltab.on{color:var(--accent2);border-color:var(--accent2)}
/* raw telemetry box */
.rawbox{display:none;background:#050508;padding:6px 4px;font-family:var(--mono);font-size:9px;max-height:240px;overflow-y:auto;letter-spacing:0;line-height:1.45}
.rl{display:flex;gap:3px;padding:1px 4px;border-bottom:1px solid rgba(46,46,51,.4);word-break:break-all}
.rl:hover{background:rgba(108,99,255,.05)}
.rk{color:#2d3550;flex-shrink:0;user-select:none}  /* key: timestamp+seq+type */
.rv{color:#39d353;white-space:pre-wrap}             /* value: xor-b64 payload */
.rv.e{color:#f87171}.rv.w{color:#fb923c}.rv.p{color:#a78bfa}.rv.s{color:#60a5fa}
/* export strip */
.rawfoot{display:none;border-top:1px solid var(--border)}
.rawfoot button{width:100%;padding:5px 10px;background:none;border:none;color:var(--txt3);font-size:10px;font-family:var(--mono);cursor:pointer;text-align:left;transition:.15s}
.rawfoot button:hover{color:var(--txt2);background:var(--bg3)}
.ll{display:flex;gap:6px;padding:2px 4px;border-bottom:1px solid var(--border);align-items:flex-start;animation:fi .1s}
.ll:hover{background:var(--bg3)}
.lt{font-size:9px;padding:1px 5px;border-radius:3px;font-weight:700;flex-shrink:0;margin-top:1px;text-transform:uppercase}
.tl{background:#1e2a3a;color:var(--info)}.tw{background:#2a1f0d;color:var(--warn)}
.te{background:#2a1010;color:var(--err)}.ts{background:#1a2a1e;color:var(--ok)}
.tp{background:#1a1a2a;color:var(--accent2)}
.lm{flex:1;color:#e2e8f0;word-break:break-all;white-space:pre-wrap;line-height:1.4}
.lts{color:var(--txt3);font-size:9px;flex-shrink:0;margin-top:2px}
@keyframes fi{from{opacity:0;transform:translateY(-2px)}to{opacity:1;transform:none}}
/* changelog sheet */
#cl{display:none;position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:99;backdrop-filter:blur(3px);align-items:flex-end}
#cl.show{display:flex}
.sheet{background:var(--bg2);width:100%;max-height:65dvh;border-radius:16px 16px 0 0;border:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden}
.shdr{display:flex;align-items:center;padding:10px 14px;border-bottom:1px solid var(--border);font-size:12px;font-weight:700}
.shdr .spacer{flex:1}
.xbtn{background:none;border:none;color:var(--txt2);font-size:20px;cursor:pointer;line-height:1;padding:0 2px}
.sbody{flex:1;overflow-y:auto;padding:12px;font-family:var(--mono);font-size:11px;color:var(--txt2)}
.cv{color:var(--accent2);font-weight:700;margin:10px 0 2px}.cv:first-child{margin-top:0}
.cd{font-size:10px;color:var(--txt3);margin-bottom:2px}
.cn{font-size:10px;color:var(--txt2);margin-bottom:8px}
/* toast */
#toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%) translateY(20px);background:var(--bg4);color:var(--txt);font-size:11px;padding:6px 14px;border-radius:20px;border:1px solid var(--border);opacity:0;transition:.2s;pointer-events:none;z-index:999;white-space:nowrap}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
#sf-frame{display:none}
</style>
</head>
<body>

<div id="topbar">
  <span class="logo">‚ùÑÔ∏è Snowflake</span>
  <span class="ver">v2.5.0</span>
  <div class="spacer"></div>
  <button class="tbtn" id="clr-btn">Clear</button>
  <button class="tbtn" id="cl-btn">üìã</button>
</div>

<div id="scroll">
  <!-- Control -->
  <div class="card">
    <div class="card-hdr">
      <span class="dot" id="dot-main"></span>
      <span id="hdr-txt">Proxy Control</span>
      <div class="spacer"></div>
      <span id="hdr-uptime" style="font-size:10px;color:var(--txt3)">00:00:00</span>
    </div>
    <div class="card-body">
      <div class="mrow">
        <div class="mlbl">
          <h3>Enable Snowflake</h3>
          <p>Help censored users access Tor via WebRTC relay</p>
        </div>
        <label class="toggle">
          <input type="checkbox" id="sw" onchange="onToggle(this.checked)">
          <span class="tsl"></span>
        </label>
      </div>
      <div class="pill p-off" id="pill"><span class="pdot"></span><span id="pill-txt">Stopped</span></div>
      <div id="statusdesc-ui"></div>
      <button id="retry-btn" onclick="onRetry()">‚Üª Retry Connection</button>
      <div id="ubar"><div id="ufill"></div></div>
    </div>
  </div>

  <!-- Stats -->
  <div class="card">
    <div class="card-hdr"><span class="dot ok"></span><span>Statistics</span></div>
    <div class="card-body">
      <div class="stats">
        <div class="stat"><div class="slbl">Active Clients</div><div class="sval" id="s-clients">0</div><div class="ssub">live now</div></div>
        <div class="stat"><div class="slbl">Total Served</div><div class="sval" id="s-total">0</div><div class="ssub">all-time</div></div>
        <div class="stat"><div class="slbl">NAT Type</div><div class="sval" id="s-nat" style="font-size:13px">‚Äî</div><div class="ssub">network</div></div>
        <div class="stat"><div class="slbl">Session Uptime</div><div class="sval" id="s-uptime" style="font-size:13px">0s</div><div class="ssub">running</div></div>
      </div>
    </div>
  </div>

  <!-- Console -->
  <div class="card">
    <div class="card-hdr">
      <span class="dot" id="dot-log"></span>
      <span>Proxy Console</span>
      <div class="spacer"></div>
      <span id="log-count" style="font-size:10px;background:var(--bg4);padding:1px 7px;border-radius:10px;transition:.3s">0</span>
    </div>
    <div class="ltabs">
      <button class="ltab on" id="ltab-disp" onclick="setLogTab('disp')">Display</button>
      <button class="ltab" id="ltab-raw" onclick="setLogTab('raw')">Raw</button>
    </div>
    <div id="logbox" class="logbox"></div>
    <div id="rawbox" class="rawbox"></div>
    <div class="rawfoot" id="rawfoot">
      <button onclick="exportRaw()">‚¨á export telemetry.log</button>
    </div>
  </div>
</div>

<!-- Changelog -->
<div id="cl" onclick="if(event.target===this)closeCL()">
  <div class="sheet">
    <div class="shdr">üìã Changelog<div class="spacer"></div><button class="xbtn" onclick="closeCL()">√ó</button></div>
    <div class="sbody">
      <div class="cv">v2.5.0</div><div class="cd">+18 -9</div>
      <div class="cn">startup fixes: DOMContentLoaded‚Üíready postMessage before sfInit (iframe unblocks dashboard early); tryProbe non-blocking (relay probe runs bg, broker poll starts immediately); defaultBrokerPollInterval=fastBrokerPollInterval on first run (30s not 60s); xhr.timeout=35s added to broker XHR; toggle queues start before sfReady</div>
      <div class="cv">v2.4.0</div><div class="cd">+78 -8</div>
      <div class="cn">dual-mode log: Display tab (human-readable) + Raw tab (machine telemetry); format T{abs}D{delta}|{seq_hex}|{2c_type} {xor0x5F‚Üíb64}; every postMessage frame captured; export to .log; buffer 3k entries; Clear resets both</div>
      <div class="cv">v2.3.0</div><div class="cd">+312 -98</div>
      <div class="cn">popup.js integrated ‚Äî Popup class runs in srcdoc with DOM stubs; all state methods (_post hooks) relay via postMessage; inline msg map replaces _locales; retry flow wired; missingFeature distinguishes bridge/webrtc/storage errors; StandaloneUI wraps real Popup</div>
      <div class="cv">v2.2.0</div><div class="cd">+267 -198</div>
      <div class="cn">srcdoc sandbox bridge pattern from sandbox-v1_0; StandaloneUI replaced BadgeUI; engine runs in hidden iframe; postMessage bidirectional</div>
      <div class="cv">v2.1.0</div><div class="cd">+89 -312</div>
      <div class="cn">Surfaced CORS block on broker XHR; analysis version</div>
      <div class="cv">v2.0.0</div><div class="cd">+201 -0</div>
      <div class="cn">First attempt with embed.js; failed on missing locales + Popup + BadgeUI deps</div>
    </div>
  </div>
</div>

<div id="toast"></div>
<iframe id="sf-frame" sandbox="allow-scripts allow-same-origin" title="snowflake-proxy"></iframe>

<script>
const $=id=>document.getElementById(id);
const S={enabled:false,clients:0,total:0,nat:'‚Äî',logN:0,errN:0,startTs:0,uptimeSec:0,sfReady:false,retryAvail:false};
let uptimeTick=null;

// ‚îÄ‚îÄ All JS for srcdoc (engine + popup + init) ‚îÄ‚îÄ
const SF_SRC=`const availableLangs = new Map([
['en_US', 'English'],
['sq', 'shqip'],
['ar', 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©'],
['be', '–±–µ–ª–∞—Ä—É—Å–∫–∞—è'],
['bn', '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ'],
['bg', '–±—ä–ª–≥–∞—Ä—Å–∫–∏'],
['ca', 'catal√†'],
['zh_CN', '‰∏≠Êñá'],
['cs', 'ƒçe≈°tina'],
['nl', 'Nederlands'],
['fi', 'suomi'],
['fr', 'fran√ßais'],
['ka', '·É•·Éê·É†·Éó·É£·Éö·Éò'],
['de', 'Deutsch'],
['el', 'ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨'],
['hu', 'magyar'],
['is', '√≠slenska'],
['ga_IE', 'Gaeilge'],
['it', 'italiano'],
['ja', 'Êó•Êú¨Ë™û'],
['ko', 'ÌïúÍµ≠Ïñ¥'],
['fa', 'ŸÅÿßÿ±ÿ≥€å'],
['pl', 'polski'],
['pt_BR', 'portugu√™s'],
['pt_PT', 'portugu√™s'],
['ro', 'rom√¢nƒÉ'],
['ru', '—Ä—É—Å—Å–∫–∏–π'],
['es', 'espa√±ol'],
['sv_SE', 'svenska'],
['tr', 'T√ºrk√ße'],
['uk', '—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞'],
['vi', 'Ti·∫øng Vi·ªát'],
]);

/* global log, dbg, snowflake */

/**
Communication with the snowflake broker.

Browser snowflakes must register with the broker in order
to get assigned to clients.
*/

// Represents a broker running remotely.
class Broker {

  /**
   * When interacting with the Broker, snowflake must generate a unique session
   * ID so the Broker can keep track of each proxy's signalling channels.
   * On construction, this Broker object does not do anything until
   * \`getClientOffer\` is called.
   * @param {Config} config
   */
  constructor(config) {
    this.getClientOffer = this.getClientOffer.bind(this);
    this._postRequest = this._postRequest.bind(this);
    this.setNATType = this.setNATType.bind(this);

    this.config = config;
    this.url = config.brokerUrl;
    this.natType = "unknown";
    if (0 === this.url.indexOf('localhost', 0)) {
      // Ensure url has the right protocol + trailing slash.
      this.url = 'http://' + this.url;
    }
    if (0 !== this.url.indexOf('http', 0)) {
      this.url = 'https://' + this.url;
    }
    if ('/' !== this.url.substr(-1)) {
      this.url += '/';
    }
  }

  /**
   * Promises some client SDP Offer.
   * Registers this Snowflake with the broker using an HTTP POST request, and
   * waits for a response containing some client offer that the Broker chooses
   * for this proxy..
   * Rejects on timeout or on error.
   * TODO: Actually support multiple clients.
   */
  getClientOffer(id, numClientsConnected) {
    return new Promise((fulfill, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.DONE !== xhr.readyState) {
          return;
        }
        if (xhr.status !== Broker.CODE.OK) {
          log('Broker ERROR: Unexpected ' + xhr.status + ' - ' + xhr.statusText);
          snowflake.ui.setStatus(' failure. Please refresh.');
          reject(Broker.MESSAGE.UNEXPECTED);
          return;
        }
        const response = JSON.parse(xhr.responseText);
        switch (response.Status) {
          case Broker.STATUS.MATCH: fulfill(response); return;
          case Broker.STATUS.TIMEOUT: reject(Broker.MESSAGE.TIMEOUT); return;
          default: {
            log('Broker ERROR: Unexpected ' + response.Status);
            reject(Broker.MESSAGE.UNEXPECTED);
            return;
          }
        }
      };
      this._xhr = xhr; // Used by spec to fake async Broker interaction
      const clients = Math.floor(numClientsConnected / 8) * 8;
      const data = {
        Version: "1.3",
        Sid: id,
        Type: this.config.proxyType,
        NAT: this.natType,
        Clients: clients,
        AcceptedRelayPattern: this.config.allowedRelayPattern,
      };
      this._postRequest(xhr, 'proxy', JSON.stringify(data));
    });
  }

  /**
   * Assumes getClientOffer happened, and a WebRTC SDP answer has been generated.
   * Sends it back to the broker, which passes it to back to the original client.
   * @param {string} id
   * @param {RTCSessionDescription} answer
   */
  sendAnswer(id, answer) {
    dbg(id + ' - Sending answer back to broker...\n');
    dbg(answer.sdp);
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.DONE !== xhr.readyState) {
        return;
      }
      switch (xhr.status) {
        case Broker.CODE.OK:
          dbg('Broker: Successfully replied with answer.');
          dbg(xhr.responseText);
          break;
        default:
          dbg('Broker ERROR: Unexpected ' + xhr.status + ' - ' + xhr.statusText);
          snowflake.ui.setStatus(' failure. Please refresh.');
          break;
      }
    };
    const data = {"Version": "1.0", "Sid": id, "Answer": JSON.stringify(answer)};
    this._postRequest(xhr, 'answer', JSON.stringify(data));
  }

  setNATType(natType) {
    this.natType = natType;
  }

  /**
   * @param {XMLHttpRequest} xhr
   * @param {string} urlSuffix for the broker is different depending on what action
   * is desired.
   * @param {string} payload
   */
  _postRequest(xhr, urlSuffix, payload) {
    try {
      xhr.open('POST', this.url + urlSuffix);
    } catch (err) {
      /*
      An exception happens here when, for example, NoScript allows the domain
      on which the proxy badge runs, but not the domain to which it's trying
      to make the HTTP xhr. The exception message is like "Component
      returned failure code: 0x805e0006 [nsIXMLHttpRequest.open]" on Firefox.
      */
      log('Broker: exception while connecting: ' + err.message);
      return;
    }
    xhr.timeout = 35000; // 35s cap ‚Äî broker long-polls up to ~30s, give 5s buffer
    xhr.ontimeout = function() { log('Broker XHR timeout'); };
    xhr.send(payload);
  }

}

Broker.CODE = {
  OK: 200,
  BAD_REQUEST: 400,
  INTERNAL_SERVER_ERROR: 500
};

Broker.STATUS = {
  MATCH: "client match",
  TIMEOUT: "no match"
};

Broker.MESSAGE = {
  TIMEOUT: 'Timed out waiting for a client offer.',
  UNEXPECTED: 'Unexpected status.'
};


class Config {
  constructor(proxyType) {
    this.proxyType = proxyType || '';
  }
}

Config.prototype.brokerUrl = 'snowflake-broker.torproject.net';

Config.prototype.defaultRelayAddr = 'wss://snowflake.freehaven.net';

// Original non-wss relay:
// host: '192.81.135.242'
// port: 9902

// Bytes per second. Set to undefined to disable limit.
Config.prototype.rateLimitBytes = undefined;

Config.prototype.minRateLimit = 10 * 1024;

Config.prototype.rateLimitHistory = 5.0;

Config.prototype.defaultBrokerPollInterval = 60.0 * 1000; //1 poll every minutes
Config.prototype.slowestBrokerPollInterval = 6 * 60 * 60.0 * 1000; //1 poll every 6 hours
Config.prototype.pollAdjustment = 100.0 * 1000;
Config.prototype.fastBrokerPollInterval = 30 * 1000; //1 poll every 30 seconds

// Recheck our NAT type once every 2 days
Config.prototype.natCheckInterval = 2 * 24 * 60 * 60 * 1000;

// Timeout after sending answer before datachannel is opened
Config.prototype.datachannelTimeout = 20 * 1000;

// Timeout to close proxypair if no messages are sent
Config.prototype.messageTimeout = 30 * 1000;

// This must be smaller than the clien't timeout (\`ClientTimeout\`)
// (which is 5 seconds by default as of now), otherwise the client would be
// gone before we send the answer.
// And it, obviously, must be smaller than \`datachannelTimeout\`.
Config.prototype.answerTimeout = 3 * 1000;

Config.prototype.maxNumClients = 1;

Config.prototype.proxyType = "";

// TODO: Different ICE servers.
Config.prototype.pcConfig = {
  iceServers: [
    {
      urls: ['stun:stun.l.google.com:19302']
    }
  ]
};

Config.PROBEURL = "https://snowflake-broker.torproject.net:8443/probe";

Config.prototype.allowedRelayPattern="snowflake.torproject.net";
/* global snowflake, log, dbg, debug, Util, Parse, WS */

/**
Represents a single:

   client <-- webrtc --> snowflake <-- websocket --> relay

Every ProxyPair has a Snowflake ID, which is necessary when responding to the
Broker with an WebRTC answer.
*/

class ProxyPair {

  /**
   * @param {DummyRateLimit | BucketRateLimit} rateLimit specifies a rate limit on traffic
   * @param {Config} config
   */
  constructor(rateLimit, config) {
    this.prepareDataChannel = this.prepareDataChannel.bind(this);
    this.connectRelay = this.connectRelay.bind(this);
    this.onClientToRelayMessage = this.onClientToRelayMessage.bind(this);
    this.onRelayToClientMessage = this.onRelayToClientMessage.bind(this);
    this.onError = this.onError.bind(this);
    this.flush = this.flush.bind(this);

    /** @type {string | URL} */
    this.relayURL = config.defaultRelayAddr;
    this.rateLimit = rateLimit;
    this.config = config;
    this.id = Util.genSnowflakeID();
    this.c2rSchedule = [];
    this.r2cSchedule = [];
    this.nowConnected = false;
  }

  /** Prepare a WebRTC PeerConnection and await for an SDP offer. */
  begin() {
    /** @private */
    this.pc = new RTCPeerConnection(this.config.pcConfig);
    // OnDataChannel triggered remotely from the client when connection succeeds.
    this.pc.ondatachannel = ({ channel }) => {
      dbg('Data Channel established...');
      this.prepareDataChannel(channel);
      /** @private */
      this.client = channel;
    };
  }

  /**
   * @param {RTCSessionDescription} offer
   * @param {(answer: RTCSessionDescription) => void} sendAnswer
   * @returns {boolean} \`true\` on success, \`false\` on fail.
   */
  receiveWebRTCOffer(offer, sendAnswer) {
    if ('offer' !== offer.type) {
      log('Invalid SDP received -- was not an offer.');
      return false;
    }
    dbg('SDP ' + offer.type + ' successfully received.');

    this.pc.setRemoteDescription(offer)
    // Since we don't have a singaling channel, besides the initial offer/answer,
    // mark the end of ICE candidates, in case it's not already marked in the offer.
    .then(() => this.pc.addIceCandidate({ candidate: '' }))
    .then(() => this.pc.createAnswer())
    .then((sdp) => {
      dbg('webrtc: Answer ready.');
      return this.pc.setLocalDescription(sdp);
    })
    .catch(() => {
      this.close();
      dbg('webrtc: Failed to create or set Answer');
    });

    // Send the answer when ready.
    const onceSendAnswer = () => {
      sendAnswer(this.pc.localDescription);

      this.pc.onicegatheringstatechange = null;
      clearTimeout(this.answerTimeoutId);
    };
    this.pc.onicegatheringstatechange = () => {
      if (this.pc.iceGatheringState === 'complete' && this.pc.connectionState !== 'closed') {
        dbg('Finished gathering ICE candidates.');
        onceSendAnswer();
      }
    };
    if (this.pc.iceGatheringState === 'complete') {
      // This probably never happens as we've \`setRemoteDescription\` just now,
      // but let's play it safe.
      onceSendAnswer();
    } else {
      this.answerTimeoutId = setTimeout(() => {
        dbg('answerTimeout');
        // ICE gathering is taking a while to complete - send what we got so far.
        if (!this.pc.localDescription) {
          // We don't have anything to send yet. Sigh. The client will probably timeout waiting
          // for us, but let's not bail and just try to wait some more in hope that it won't.
          // Worst case scenario - \`datachannelTimeout\` callback will run.
          return;
        }
        onceSendAnswer();
      }, this.config.answerTimeout);
    }

    this.connectRelay(offer);

    return true;
  }

  /**
   * Given a WebRTC DataChannel, prepare callbacks.
   * @param {RTCDataChannel} channel
   * @private
   */
  prepareDataChannel(channel) {
    channel.onopen = () => {
      log('WebRTC DataChannel opened!');
      snowflake.ui.increaseClients();
      this.nowConnected = true;

      // if we don't receive any keep-alive messages from the client, close the
      // connection
      const onStaleTimeout = () => {
        console.log("Closing stale connection.");
        this.flush();
        this.close();
      };
      this.refreshStaleTimeout = () => {
        clearTimeout(this.messageTimer);
        this.messageTimer = setTimeout(onStaleTimeout, this.config.messageTimeout);
      };
      this.refreshStaleTimeout();
    };
    channel.onclose = () => {
      log('WebRTC DataChannel closed.');
      snowflake.ui.setStatus('disconnected by webrtc.');
      if (this.nowConnected) {
        snowflake.ui.decreaseClients();
        this.nowConnected = false;
      }
      this.flush();
      this.close();
    };
    channel.onerror = function () {
      log('Data channel error!');
    };
    channel.binaryType = "arraybuffer";
    channel.onmessage = this.onClientToRelayMessage;
  }

  /**
   * @param {RTCSessionDescription} remoteDescription
   * @private
   */
  connectRelay(remoteDescription) {
    dbg('Connecting to relay...');
    // Get a remote IP address from the PeerConnection, if possible. Add it to
    // the WebSocket URL's query string if available.
    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/remoteDescription
    const clientIP = Parse.ipFromSDP(remoteDescription.sdp);
    const relay = this.relay = WS.makeWebSocket(this.relayURL, clientIP);
    relay.label = 'websocket-relay';
    relay.onopen = () => {
      clearTimeout(this.connectToRelayTimeoutId);
      log(relay.label + ' connected!');
      snowflake.ui.setStatus('connected');
    };
    relay.onclose = () => {
      log(relay.label + ' closed.');
      snowflake.ui.setStatus('disconnected.');
      if (this.nowConnected) {
        snowflake.ui.decreaseClients();
        this.nowConnected = false;
      }
      this.flush();
      this.close();
    };
    relay.onerror = this.onError;
    relay.onmessage = this.onRelayToClientMessage;
    // TODO: Better websocket timeout handling.
    this.connectToRelayTimeoutId = setTimeout((() => {
      log(relay.label + ' timed out connecting.');
      relay.onclose();
    }), 5000);
  }

  /**
   * WebRTC --> websocket
   * @param {MessageEvent} msg
   * @private
   */
  onClientToRelayMessage(msg) {
    this.c2rSchedule.push(msg.data);
    this.flush();

    this.refreshStaleTimeout();
  }

  /**
   * websocket --> WebRTC
   * @param {MessageEvent} event
   * @private
   */
  onRelayToClientMessage(event) {
    this.r2cSchedule.push(event.data);
    this.flush();
  }

  /** @private */
  onError(event) {
    const ws = event.target;
    log(ws.label + ' error.');
    this.close();
  }

  /** Close both WebRTC and websocket. */
  close() {
    if (debug) {
      this.pc.getStats().then(report => {
        let transportStats;
        for (const stat of report.values()) {
          // Also consider 'data-channel'.
          if (stat.type === 'transport') {
            transportStats = stat;
            break;
          }
        }
        if (!transportStats) {
          return;
        }
        function bytesToMBytesStr(numBytes) {
          return (numBytes / 1024 / 1024).toFixed(3);
        }
        log(
          \`Connection closed. Traffic (up|down):\`
          + \` \${bytesToMBytesStr(transportStats.bytesReceived)} MB|\`
          + \`\${bytesToMBytesStr(transportStats.bytesSent)} MB\`
          + \`, packets: \${transportStats.packetsReceived}|\`
          + \`\${transportStats.packetsSent}\`
        );
      });
    }

    clearTimeout(this.connectToRelayTimeoutId);
    clearTimeout(this.messageTimer);
    clearTimeout(this.answerTimeoutId);
    clearTimeout(this.flush_timeout_id);
    if (this.webrtcIsReady()) {
      this.client.close();
    }
    if (this.peerConnOpen()) {
      this.pc.close();
    }
    if (this.relayIsReady()) {
      this.relay.close();
    }
    this.onCleanup();
  }

  /**
   * Send as much data in both directions as the rate limit currently allows.
   * @private
   */
  flush() {
    let busy = true;
    while (busy && !this.rateLimit.isLimited()) {
      busy = false;
      // WebRTC --> websocket
      if (this.c2rSchedule.length > 0 && this.relayIsReady() && this.relay.bufferedAmount < this.MAX_BUFFER) {
        const chunk = this.c2rSchedule.shift();
        this.relay.send(chunk);
        this.rateLimit.update(chunk.byteLength);
        busy = true;
      }
      // websocket --> WebRTC
      if (this.r2cSchedule.length > 0 && this.webrtcIsReady() && this.client.bufferedAmount < this.MAX_BUFFER) {
        const chunk = this.r2cSchedule.shift();
        this.client.send(chunk);
        this.rateLimit.update(chunk.byteLength);
        busy = true;
      }
    }

    if (this.flush_timeout_id) {
      clearTimeout(this.flush_timeout_id);
      this.flush_timeout_id = 0;
    }
    if (this.r2cSchedule.length > 0 || this.c2rSchedule.length > 0) {
      this.flush_timeout_id = setTimeout(this.flush, this.rateLimit.when() * 1000);
    }
  }

  webrtcIsReady() {
    return null !== this.client && 'open' === this.client.readyState;
  }

  relayIsReady() {
    return (null !== this.relay) && (WebSocket.OPEN === this.relay.readyState);
  }

  peerConnOpen() {
    return (null !== this.pc) && ('closed' !== this.pc.connectionState);
  }

  /**
   * @param {URL | string} relayURL
   */
  setRelayURL(relayURL) {
    this.relayURL = relayURL;
  }

}

ProxyPair.prototype.MAX_BUFFER = 10 * 1024 * 1024;

ProxyPair.prototype.pc = null;
ProxyPair.prototype.client = null; // WebRTC Data channel
ProxyPair.prototype.relay = null; // websocket

ProxyPair.prototype.connectToRelayTimeoutId = 0;
ProxyPair.prototype.messageTimer = 0;
ProxyPair.prototype.answerTimeoutId = 0;
ProxyPair.prototype.flush_timeout_id = 0;

ProxyPair.prototype.onCleanup = () => {};
/* global log, dbg, DummyRateLimit, BucketRateLimit, ProxyPair, Util */

/**
A JavaScript WebRTC snowflake proxy

Uses WebRTC from the client, and Websocket to the server.

Assume that the webrtc client plugin is always the offerer, in which case
this proxy must always act as the answerer.

TODO: More documentation
*/

class Snowflake {

  /**
   * Prepare the Snowflake with a Broker (to find clients) and optional UI.
   * @param {Config} config
   * @param {WebExtUI | BadgeUI | DebugUI} ui
   * @param {Broker} broker
   */
  constructor(config, ui, broker) {
    this.receiveOffer = this.receiveOffer.bind(this);

    this.config = config;
    this.ui = ui;
    this.broker = broker;
    this.broker.setNATType(ui.natType);
    this.proxyPairs = [];
    this.natFailures = 0;
    this.pollInterval = this.config.defaultBrokerPollInterval;
    if (undefined === this.config.rateLimitBytes) {
      this.rateLimit = new DummyRateLimit();
    } else {
      this.rateLimit = new BucketRateLimit(this.config.rateLimitBytes * this.config.rateLimitHistory, this.config.rateLimitHistory);
    }
    this.retries = 0;
  }

  /**
   * Start asking the broker for clients and serving them.
   */
  beginServingClients() {
    if (this.proxyPairs.length < this.config.maxNumClients) {
      this.pollBroker();
    } else {
      dbg('Polling skipped: at client capacity.');
    }
    this.pollTimeoutId = setTimeout((() => {
      this.beginServingClients();
    }), this.pollInterval);
  }

  /**
   * Try to get a client from the broker and start serving it upon success.
   * @private
   */
  pollBroker() {
    const pair = this.makeProxyPair();
    log('Polling broker..');

    let msg = 'Polling for client ... ';
    if (this.retries > 0) {
      msg += '[retries: ' + this.retries + ']';
    }
    this.ui.setStatus(msg);

    //update NAT type
    console.log("NAT type: " + this.ui.natType);
    this.broker.setNATType(this.ui.natType);

    const recv = this.broker.getClientOffer(pair.id, this.proxyPairs.length);
    recv.then((resp) => {
      const clientNAT = resp.NAT;
      if (!this.receiveOffer(pair, resp.Offer, resp.RelayURL)) {
        pair.close();
        return;
      }
      //set a timeout for channel creation
      setTimeout((() => {
        if (!pair.webrtcIsReady()) {
          log('proxypair datachannel timed out waiting for open');
          pair.close();
          // increase poll interval
          this.pollInterval =
            Math.min(this.pollInterval + this.config.pollAdjustment,
              this.config.slowestBrokerPollInterval);
          if (clientNAT == "restricted") {
            this.natFailures++;
          }
          // if we fail to connect to a restricted client 5 times in
          // a row, trigger a re-check of our NAT type
          if (this.natFailures >= 5) {
            this.natFailures = 0;
            this.config.maxNumClients = 1;
            console.log("Too many data channel failures, re-checking NAT type");
            Util.checkNATType(this.config.datachannelTimeout).then((type) => {
              console.log("Setting NAT type: " + type);
              this.ui.natType = type;
              this.broker.setNATType(type);
            }).catch((e) => {
              console.log(e);
            });
          }
        } else {
          // decrease poll interval
          this.pollInterval =
            Math.max(this.pollInterval - this.config.pollAdjustment,
              this.config.defaultBrokerPollInterval);
          this.natFailures = 0;
          if (this.ui.natType == "unrestricted") {
            this.pollInterval = this.config.fastBrokerPollInterval;
            this.config.maxNumClients = 2;
          }
        }
      }), this.config.datachannelTimeout);
    }, function () {
      //on error, close proxy pair
      pair.close();
    });
    this.retries++;
  }

  /**
   * Receive an SDP offer from some client assigned by the Broker
   * @param {ProxyPair} pair an available ProxyPair.
   * @param {string} desc
   * @param {string | undefined} relayURL
   * @returns {boolean} \`true\` on success, \`false\` on fail.
   * @private
   */
  receiveOffer(pair, desc, relayURL) {
    try {
      if (relayURL !== undefined) {
        const relayURLParsed = new URL(relayURL);
        const hostname = relayURLParsed.hostname;
        const protocol = relayURLParsed.protocol;
        if (protocol !== "wss:") {
          log('incorrect relay url protocol');
          return false;
        }
        if (!Snowflake.checkRelayPattern(this.config.allowedRelayPattern, hostname)) {
          log('relay url hostname does not match allowed pattern');
          return false;
        }
        pair.setRelayURL(relayURL);
      }
      /** @type {RTCSessionDescriptionInit} */
      const offer = JSON.parse(desc);
      dbg('Received:\n\n' + offer.sdp + '\n');
      const sdp = new RTCSessionDescription(offer);
      const result = pair.receiveWebRTCOffer(
        sdp,
        answer => this.broker.sendAnswer(pair.id, answer)
      );
      return result;
    } catch (e) {
      log('ERROR: Unable to receive Offer: ' + e);
      return false;
    }
  }

  /**
   * @returns {ProxyPair}
   * @private
   */
  makeProxyPair() {
    const pair = new ProxyPair(this.rateLimit, this.config);
    this.proxyPairs.push(pair);

    log('Snowflake IDs: ' + (this.proxyPairs.map(p => p.id)).join(' | '));

    pair.onCleanup = () => {
      // Delete from the list of proxy pairs.
      const ind = this.proxyPairs.indexOf(pair);
      if (ind > -1) {
        this.proxyPairs.splice(ind, 1);
      }
    };
    pair.begin();
    return pair;
  }

  /** Stop all proxypairs. */
  disable() {
    log('Disabling Snowflake.');
    clearTimeout(this.pollTimeoutId);
    while (this.proxyPairs.length > 0) {
      this.proxyPairs.pop().close();
    }
  }

  /**
   * checkRelayPattern match str against patten
   * @param {string} pattern
   * @param {string} str typically a domain name to be checked
   * @return {boolean}
   * @private
   */
  static checkRelayPattern(pattern, str) {
    if (typeof pattern !== "string") {
      throw 'invalid checkRelayPattern input: pattern';
    }
    if (typeof str !== "string") {
      throw 'invalid checkRelayPattern input: str';
    }

    let exactMatch = false;
    if (pattern.charAt(0) === "^") {
      exactMatch = true;
      pattern = pattern.substring(1);
    }

    if (exactMatch) {
      return pattern.localeCompare(str) === 0;
    }
    return str.endsWith(pattern);
  }

}

Snowflake.prototype.rateLimit = null;

Snowflake.MESSAGE = {
  CONFIRMATION: 'You\'re currently serving a Tor user via Snowflake.'
};
/**
All of Snowflake's DOM manipulation and inputs.
*/

class UI {

  constructor() {
    this.initStats();
  }

  initStats() {
    this.stats = [0];
    setInterval((() => {
      this.stats.unshift(0);
      this.stats.splice(24);
      this.postActive();
    }), 60 * 60 * 1000);
  }

  setStatus() {}

  get active() {
    return this.clients > 0;
  }

  postActive() {}

  increaseClients() {
    this.clients += 1;
    this.stats[0] += 1;
    // Do not remove this call without a full usage search
    // its is used for status synchronization by its subclasses
    this.postActive();
    return this.clients;
  }

  decreaseClients() {
    this.clients -= 1;
    if(this.clients < 0) {
      this.clients = 0;
    }
    // Do not remove this call without a full usage search
    // its is used for status synchronization by its subclasses
    this.postActive();
    return this.clients;
  }

  log() {}

}

UI.prototype.clients = 0;
UI.prototype.stats = null;
/* exported Util, Params, DummyRateLimit */
/* global Config */

/**
A JavaScript WebRTC snowflake proxy

Contains helpers for parsing query strings and other utilities.
*/

class Util {

  static genSnowflakeID() {
    return Math.random().toString(36).substring(2);
  }

  static hasWebRTC() {
    return typeof RTCPeerConnection === 'function';
  }

  // check to see that localStorage is not only supported
  // but also that there is storage space available
  // see https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#testing_for_availability
  static hasLocalStorage() {
    try {
      const x = "snowflake-allow";
      localStorage.setItem(x, x);
      localStorage.removeItem(x);
      return true;
    } catch (e) {
      return (
        e instanceof DOMException &&
        e.name === "QuotaExceededError" &&
        // acknowledge QuotaExceededError only if there's something already stored
        localStorage &&
        localStorage.length !== 0
      );
    }
  }

  /**
   * @returns {Promise<"restricted" | "unrestricted">}
   * resolves to "restricted" if we
   * fail to make a test connection to a known restricted
   * NAT, "unrestricted" if the test connection succeeds, and
   * "unknown" if we fail to reach the probe test server
   * @param {number} timeout
   */
  static checkNATType(timeout) {
    let pc = new RTCPeerConnection({iceServers: [
      {urls: 'stun:stun1.l.google.com:19302'}
    ]});
    let channel = pc.createDataChannel("NAT test");
    return (new Promise((fulfill, reject) => {
      let open = false;
      channel.onopen = function() {
        open = true;
        fulfill("unrestricted");
      };
      pc.onicecandidate = (evt) => {
        if (evt.candidate == null) {
          //ice gathering is finished
          Util.sendOffer(pc.localDescription)
          .then((answer) => {
            setTimeout(() => {
              if(!open) {
                fulfill("restricted");
              }
            }, timeout);
            pc.setRemoteDescription(JSON.parse(answer));
          }).catch((e) => {
            console.log(e);
            reject("Error receiving probetest answer");
          });
        }
      };
      pc.createOffer()
      .then((offer) =>  pc.setLocalDescription(offer))
      .catch((e) => {
        console.log(e);
        reject("Error creating offer for probetest");
      });
    }).finally(() => {
      channel.close();
      pc.close();
    }));
  }

  /**
   * Assumes getClientOffer happened, and a WebRTC SDP answer has been generated.
   * Sends it back to the broker, which passes it back to the original client.
   * @param {RTCSessionDescription} offer
   */
  static sendOffer(offer) {
    return new Promise((fulfill, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.timeout = 30 * 1000;
      xhr.onreadystatechange = function() {
        if (xhr.DONE !== xhr.readyState) {
          return;
        }
        switch (xhr.status) {
          case 200: {
            const response = JSON.parse(xhr.responseText);
            return fulfill(response.Answer); // Should contain offer.
          }
          default:
            console.log('Probe ERROR: Unexpected ' + xhr.status + ' - ' + xhr.statusText);
            return reject('Failed to get answer from probe service');
        }
      };
      const data = {"Status": "client match", "Offer": JSON.stringify(offer)};
      try {
        xhr.open('POST', Config.PROBEURL);
      } catch (error) {
        console.log('Signaling Server: exception while connecting: ' + error.message);
        return reject('unable to connect to signaling server');
      }
      xhr.send(JSON.stringify(data));
    });
  }
}


class Parse {

  /**
   * @param {typeof document.cookie} cookies
   * Parse a cookie data string (usually document.cookie). The return type is an
   * object mapping cookies names to values. Returns null on error.
   * http://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-8747038
   */
  static cookie(cookies) {
    const result = {};
    const strings = cookies ? cookies.split(';') : [];
    for (let i = 0, len = strings.length; i < len; i++) {
      const string = strings[i];
      const j = string.indexOf('=');
      if (-1 === j) {
        return null;
      }
      const name = decodeURIComponent(string.substr(0, j).trim());
      const value = decodeURIComponent(string.substr(j + 1).trim());
      if (!(name in result)) {
        result[name] = value;
      }
    }
    return result;
  }

  /**
   * Parse a count of bytes. A suffix of 'k', 'm', or 'g' (or uppercase)
   * does what you would think. Returns null on error.
   */
  static byteCount(spec) {
    let matches = spec.match(/^(\d+(?:\.\d*)?)(\w*)$/);
    if (matches === null) {
      return null;
    }
    let count = Number(matches[1]);
    if (isNaN(count)) {
      return null;
    }
    const UNITS = new Map([
      ['', 1],
      ['k', 1024],
      ['m', 1024*1024],
      ['g', 1024*1024*1024],
    ]);
    let unit = matches[2].toLowerCase();
    if (!UNITS.has(unit)) {
      return null;
    }
    let multiplier = UNITS.get(unit);
    return count * multiplier;
  }

  /**
   * Parse a remote connection-address out of the "c=" Connection Data field
   * or the "a=" attribute fields of the session description.
   * Return undefined if none is found.
   * https://tools.ietf.org/html/rfc4566#section-5.7
   * https://tools.ietf.org/html/rfc5245#section-15
   */
  static ipFromSDP(sdp) {
    console.log(sdp);
    const ref = [
      /^a=candidate:[a-zA-Z0-9+/]+ \d+ udp \d+ ([\d.]+) /mg,
      /^a=candidate:[a-zA-Z0-9+/]+ \d+ udp \d+ ([0-9A-Fa-f:.]+) /mg,
      /^c=IN IP4 ([\d.]+)(?:(?:\/\d+)?\/\d+)?(:? |$)/mg,
      /^c=IN IP6 ([0-9A-Fa-f:.]+)(?:\/\d+)?(:? |$)/mg
    ];
    for (let i = 0, len = ref.length; i < len; i++) {
      const pattern = ref[i];
      let m = pattern.exec(sdp);
      while (m != null) {
        if(Parse.isRemoteIP(m[1])) return m[1];
        m = pattern.exec(sdp);
      }
    }
  }

  /**
   * Parse the mapped port out of an ice candidate returned from the
   * onicecandidate callback
   */
  static portFromCandidate(c) {
    const pattern = /(?:[\d.]+|[0-9A-Fa-f:.]+) (\d+) typ srflx/m;
    const m = pattern.exec(c);
    if (m != null) {
      return m[1];
    }
    return null;
  }

  /** Determine whether an IP address is a local, unspecified, or loopback address */
  static isRemoteIP(ip) {
    if (ip.includes(":")) {
      const ip6 = ip.split(':');
      // Loopback address
      const loopback = /^(?:0*:)*?:?0*1$/m;
      // Unspecified address
      const unspecified = /^(?:0*:)*?:?0*$/m;
      // Local IPv6 addresses are defined in https://tools.ietf.org/html/rfc4193
      return !((loopback.exec(ip) != null) || (unspecified.exec(ip) != null) ||
        (parseInt(ip6[0],16)&0xfe00) == 0xfc00);
    }

    // Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918
    const ip4 = ip.split('.');
    return !(ip4[0] == 10 || ip4[0] == 127 || ip == "0.0.0.0" ||
      (ip4[0] == 172 && (ip4[1]&0xf0) == 16) ||
      (ip4[0] == 192 && ip4[1] == 168) ||
      // Carrier-Grade NAT as per https://tools.ietf.org/htm/rfc6598
      (ip4[0] == 100 && (ip4[1]&0xc0) == 64) ||
      // Dynamic Configuration as per https://tools.ietf.org/htm/rfc3927
      (ip4[0] == 169 && ip4[1] == 254));
  }

}


class Params {

  static getBool(query, param, defaultValue) {
    if (!query.has(param)) {
      return defaultValue;
    }
    const val = query.get(param);
    if ('true' === val || '1' === val || '' === val) {
      return true;
    }
    if ('false' === val || '0' === val) {
      return false;
    }
    return null;
  }

  /**
   * Get an object value and parse it as a byte count. Example byte counts are
   * '100' and '1.3m'. Returns |defaultValue| if param is not a key. Return null
   * on a parsing error.
   */
  static getByteCount(query, param, defaultValue) {
    if (!query.has(param)) {
      return defaultValue;
    }
    return Parse.byteCount(query.get(param));
  }

}


class BucketRateLimit {

  constructor(capacity, time) {
    this.capacity = capacity;
    this.time = time;
  }

  age() {
    const now = new Date();
    const delta = (now - this.lastUpdate) / 1000.0;
    this.lastUpdate = now;
    this.amount -= delta * this.capacity / this.time;
    if (this.amount < 0.0) {
      this.amount = 0.0;
    }
  }

  update(n) {
    this.age();
    this.amount += n;
    return this.amount <= this.capacity;
  }

  /** How many seconds in the future will the limit expire? */
  when() {
    this.age();
    return (this.amount - this.capacity) / (this.capacity / this.time);
  }

  isLimited() {
    this.age();
    return this.amount > this.capacity;
  }

}

BucketRateLimit.prototype.amount = 0.0;

BucketRateLimit.prototype.lastUpdate = new Date();


/** A rate limiter that never limits. */
class DummyRateLimit {

  constructor(capacity, time) {
    this.capacity = capacity;
    this.time = time;
  }

  update() {
    return true;
  }

  when() {
    return 0.0;
  }

  isLimited() {
    return false;
  }

}
/*
Only WebSocket-specific stuff.
*/

// eslint-disable-next-line no-unused-vars
class WS {
  /**
   * Creates a WebSocket URL from a base URL and an optional client IP address
   * string.
   * @param {URL|string} url
   * @param {?string} clientIP
   * @return {URL}
   */
  static makeWebSocketURL(url, clientIP) {
    url = new URL(url);
    if (clientIP != null) {
      url.searchParams.set('client_ip', clientIP);
    }
    return url;
  }

  /**
   * Creates a WebSocket connection from a URL and an optional client IP address
   * string.
   * @param {URL|string} url
   * @param {?string} clientIP
   * @return {WebSocket}
   */
  static makeWebSocket(url, clientIP) {
    let ws = new WebSocket(WS.makeWebSocketURL(url, clientIP));
    /*
    'User agents can use this as a hint for how to handle incoming binary data:
    if the attribute is set to 'blob', it is safe to spool it to disk, and if it
    is set to 'arraybuffer', it is likely more efficient to keep the data in
    memory.'
    */
    ws.binaryType = 'arraybuffer';
    return ws;
  }

  /**
   * @param {URL | string} addr
   */
  static probeWebSocket(addr) {
    return /** @type {Promise<void>} */(new Promise((resolve, reject) => {
      const ws = WS.makeWebSocket(addr, null);
      ws.onopen = () => {
        resolve();
        ws.close();
      };
      ws.onerror = () => {
        reject();
        ws.close();
      };
    }));
  }

}
/* global module, require */

/*
WebRTC shims for multiple browsers.
*/

if (typeof module !== "undefined" && module !== null ? module.exports : undefined) {
  window = {};
  document = {
    getElementById: function() {
      return null;
    }
  };
  chrome = {};
  location = { search: '' };
  ({ URLSearchParams } = require('url'));
  if ((typeof TESTING === "undefined" || TESTING === null) || !TESTING) {
    webrtc = require('wrtc');
    RTCPeerConnection = webrtc.RTCPeerConnection;
    RTCSessionDescription = webrtc.RTCSessionDescription;
    WebSocket = require('ws');
    ({ XMLHttpRequest } = require('xmlhttprequest'));
  }
}
/* global chrome */

// eslint-disable-next-line no-unused-vars
function requestRemoteValue(kind, name) {
  // eslint-disable-next-line no-unused-vars
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line no-unused-vars
    let onNewMessage = (message, sender, reply) => {
      if (message.kind === "remote-value" && message.data.kind === kind && message.data.name === name) {
        chrome.runtime.onMessage.removeListener(onNewMessage);
        resolve(message.data.value);
      }
    };
    chrome.runtime.onMessage.addListener(onNewMessage);
    sendMessage('request-remote-value', {kind: kind, name: name});
  });
}

// eslint-disable-next-line no-unused-vars
function replyRemoteValue(kind, name, value) {
  sendMessage('remote-value', {kind: kind, name: name, value: value}).then();
}

// eslint-disable-next-line no-unused-vars
function diffuseRemoteValue(kind, name, value) {
  sendMessage('diffuse-value', {kind: kind, name: name, value: value}).then();
}

// eslint-disable-next-line no-unused-vars
function listenRemoteValueRequest(callback) {
  if (typeof callback !== "function") {
    throw new Error("callback must be a function");
  }
  // eslint-disable-next-line no-unused-vars
  chrome.runtime.onMessage.addListener((message, sender, reply) => {
    if (message.kind === "request-remote-value") {
      callback(message.data.kind, message.data.name);
    }
  });
}

// eslint-disable-next-line no-unused-vars
function listenDiffuseValueRequest(callback) {
  // eslint-disable-next-line no-unused-vars
  chrome.runtime.onMessage.addListener((message, sender, reply) => {
    if (message.kind === "diffuse-value") {
      callback(message.data.kind, message.data.name, message.data.value);
    }
  });
}

async function sendMessage(kind, data) {
  await chrome.runtime.sendMessage({
    kind: kind,
    data: data
  });
}
/* global chrome */

/**
 * Decide whether we need to request or revoke the 'background' permission, and
 * set the \`runInBackground\` storage value appropriately.
 * @param {boolean | undefined} enabledSetting
 * @param {boolean | undefined} runInBackgroundSetting
 */
// eslint-disable-next-line no-unused-vars
function maybeChangeBackgroundPermission(enabledSetting, runInBackgroundSetting) {
  const needBackgroundPermission =
    runInBackgroundSetting
    // When the extension is disabled, we need the permission to be revoked because
    // otherwise it'll keep the browser process running for no reason.
    && enabledSetting;
  // Yes, this is called even if the permission is already in the state we need
  // it to be in (granted/removed).
  new Promise(r => {
    chrome.permissions[needBackgroundPermission ? "request" : "remove"](
      { permissions: ['background'] },
      r
    );
  })
  .then(success => {
    // Currently the resolve value is \`true\` even when the permission was alrady granted
    // before it was requested (already removed before it was revoked). TODO Need to make
    // sure it's the desired behavior and if it needs to change.
    // https://developer.chrome.com/docs/extensions/reference/permissions/#method-remove
    // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/permissions/remove#return_value
    // https://github.com/mdn/content/pull/17516
    if (success) {
      chrome.storage.local.set({ runInBackground: runInBackgroundSetting });
    }
  });
}
/* global chrome */
/* exported Popup */

// Add or remove a class from elem.classList, depending on cond.
function setClass(elem, className, cond) {
  if (cond) {
    elem.classList.add(className);
  } else {
    elem.classList.remove(className);
  }
}


// ‚îÄ‚îÄ PostMessage bridge for Popup ‚Üí Dashboard ‚îÄ‚îÄ
function _post(type, payload) {
  try { window.parent.postMessage(Object.assign({_sf:1,type,ts:Date.now()}, payload), '*'); } catch(e){}
}
class Popup {
  /**
   * @param {() => void} [onRunInBackgroundChange]
   */
  constructor(getMsgFunc, changeFunc, retryFunc, onRunInBackgroundChange) {
    this.getMsgFunc = getMsgFunc;
    this.enabled = document.getElementById('enabled');
    this.enabled.addEventListener('change', changeFunc);
    this.retry = document.getElementById('retry');
    this.retry.addEventListener('click', () => {
      this.setStatusDesc(getMsgFunc('popupRetrying'));
      this.setRetry(false);
      this.setConsent(false);
      setTimeout(retryFunc, 1000);  // Just some UI feedback
    });
    this.consent = document.getElementById('consent');
    this.consent.addEventListener('click', () => {
      /* consent stub - no chrome API */
    });
    this.div = document.getElementById('active');
    this.statustext = document.getElementById('statustext');
    this.statusdesc = document.getElementById('statusdesc');
    this.img = document.getElementById('statusimg');
    this.enabledWrapper = document.getElementById('enabled-wrapper');
    /* runInBackground: extension-only feature, skipped */
  }
  setEnabled(enabled) {
    setClass(this.img, 'on', enabled);
    _post('enabled', {enabled});
  }
  setActive(active) {
    setClass(this.img, 'running', active);
    _post('active', {active});
  }
  setStatusText(txt) {
    this.statustext.innerText = txt;
    _post('statustext', {msg: txt});
  }
  setStatusDesc(desc, error) {
    this.statusdesc.innerText = desc;
    setClass(this.statusdesc, 'error', error);
    _post('statusdesc', {msg: desc, error: !!error});
  }
  setEnabledWrapper(hide) {
    this.enabledWrapper.style.display = hide ? 'none' : 'block';
  }
  setRetry(display) {
    this.retry.style.display = display ? 'inline-block' : 'none';
    _post('retry', {show: display});
  }
  setConsent(display) {
    this.consent.style.display = display ? 'none' : 'inline-block';
  }
  setChecked(checked) {
    this.enabled.checked = checked;
    _post('checked', {checked});
  }
  static fill(n, func) {
    switch(n.nodeType) {
      case 3: {  // Node.TEXT_NODE
        const m = /^__MSG_([^_]*)__$/.exec(n.nodeValue);
        if (m) { n.nodeValue = func(m[1]); }
        break;
      }
      case 1:  // Node.ELEMENT_NODE
        n.childNodes.forEach(c => Popup.fill(c, func));
        break;
    }
  }
  turnOn(clients, total) {
    this.setChecked(true);
    if (clients > 0) {
      this.setStatusText(this.getMsgFunc('popupStatusOn', String(clients)));
      this.active = true;
    } else {
      this.setStatusText(this.getMsgFunc('popupStatusReady'));
      this.active = false;
    }
    this.setStatusDesc((total > 0) ? this.getMsgFunc('popupDescOn', String(total)) : '');
    this.setEnabled(true);
    this.setActive(this.active);
    this.setEnabledWrapper(false);
    this.setRetry(false);
  }
  turnOff(desc, error, retry) {
    this.setChecked(false);
    this.setStatusText(this.getMsgFunc('popupStatusOff'));
    this.setStatusDesc(desc ? this.getMsgFunc(desc) : '', error);
    this.setEnabled(false);
    this.setActive(false);
    this.setEnabledWrapper(error);
    this.setRetry(retry);
  }
  missingFeature(desc) {
    this.turnOff(desc, true, desc === 'popupBridgeUnreachable');
  }
}


// ‚îÄ‚îÄ Inline message map (replaces _locales JSON) ‚îÄ‚îÄ
const MSGS = {
  popupStatusOn:      (n) => \`\${n} client\${n>1?'s':''} connected\`,
  popupStatusReady:   ()  => 'Ready ‚Äî waiting for clients',
  popupStatusOff:     ()  => 'Snowflake disabled',
  popupDescOn:        (n) => \`Helped \${n} user\${n>1?'s':''} this session\`,
  popupRetrying:      ()  => 'Retrying connection‚Ä¶',
  popupBridgeUnreachable: () => 'Bridge unreachable',
  popupWebRTCOff:     ()  => 'WebRTC not available',
  badgeLocalStorageOff: () => 'localStorage not available',
};
function getMsgFunc(key, ...args) {
  const fn = MSGS[key];
  return fn ? fn(...args) : key;
}

var debug = false;
var snowflake = null, config = null, broker = null, ui = null;
var silenceNotifications = false;
var query = new URLSearchParams(location.search);
debug = !!(query.get('debug'));

var log = function(msg) {
  console.log('Snowflake: ' + msg);
  window.parent.postMessage({_sf:1, type:'log', msg:String(msg), ts:Date.now()}, '*');
};
var dbg = function(msg) { if(debug) log(msg); };

// ‚îÄ‚îÄ BadgeUI replacement ‚Äî uses real Popup class, wires change/retry ‚îÄ‚îÄ
class StandaloneUI extends UI {
  constructor() {
    super();
    this.natType = 'unknown';
    this.enabled = false;
    this.popup = new Popup(
      getMsgFunc,
      (event) => {
        // toggle changed in DOM stub ‚Äî sync to engine
        if (event.target.checked) {
          localStorage.setItem('snowflake-allow', '1');
        } else {
          localStorage.removeItem('snowflake-allow');
        }
        sfUpdate();
      },
      () => tryProbe(),      // retry callback
      null                   // runInBackground ‚Äî extension only
    );
  }
  setStatus(s) {
    window.parent.postMessage({_sf:1, type:'status', msg:String(s), ts:Date.now()}, '*');
  }
  missingFeature(f) {
    this.popup.missingFeature(f);
    // _post already fires from inside popup methods, but also send raw key
    window.parent.postMessage({_sf:1, type:'missing', key:f, msg:getMsgFunc(f), ts:Date.now()}, '*');
  }
  turnOn() {
    this.enabled = true;
    const total = this.stats.reduce((t,c) => t+c, 0);
    this.popup.turnOn(this.clients, total);
    window.parent.postMessage({_sf:1, type:'turnon', clients:this.clients, total, ts:Date.now()}, '*');
  }
  turnOff() {
    this.enabled = false;
    this.popup.turnOff();
    window.parent.postMessage({_sf:1, type:'turnoff', ts:Date.now()}, '*');
  }
  postActive() { if(this.enabled) this.turnOn(); }
  checkNAT() {
    Util.checkNATType(config.datachannelTimeout).then((type) => {
      this.natType = type;
      broker && broker.setNATType(type);
      window.parent.postMessage({_sf:1, type:'nat', nat:type, ts:Date.now()}, '*');
    }).catch(() => {});
  }
  initNATType() {
    this.natType = 'unknown';
    this.checkNAT();
    setInterval(() => this.checkNAT(), config.natCheckInterval);
  }
  increaseClients() {
    const n = super.increaseClients();
    window.parent.postMessage({_sf:1, type:'clients', clients:n, ts:Date.now()}, '*');
    return n;
  }
  decreaseClients() {
    const n = super.decreaseClients();
    window.parent.postMessage({_sf:1, type:'clients', clients:n, ts:Date.now()}, '*');
    return n;
  }
  log(msg) {
    window.parent.postMessage({_sf:1, type:'log', msg:String(msg), ts:Date.now()}, '*');
  }
  setConsent(c) { this.popup.setConsent(c); }
}

var LOCALSTORAGE_NAME = 'snowflake-allow';

var tryProbe = function() {
  // Start broker poll immediately ‚Äî don't block on relay probe
  // The relay WebSocket connects in parallel when first client arrives (ProxyPair.connectRelay)
  // probeWebSocket only confirms relay is reachable but adds 200ms-3s of blocking delay
  ui.turnOn();
  dbg('Contacting Broker at ' + broker.url);
  log('Starting snowflake');
  snowflake.beginServingClients();
  // Background relay probe ‚Äî just log result, don't gate startup on it
  WS.probeWebSocket(config.defaultRelayAddr).then(
    () => { log('Relay reachable'); },
    () => {
      ui.missingFeature('popupBridgeUnreachable');
      snowflake.disable();
      log('Relay unreachable ‚Äî stopping.');
    }
  );
};

var sfUpdate = function() {
  if (localStorage.getItem(LOCALSTORAGE_NAME) !== '1') {
    ui.turnOff(); snowflake.disable(); return;
  }
  if (!Util.hasWebRTC()) {
    ui.missingFeature('popupWebRTCOff'); snowflake.disable(); return;
  }
  tryProbe();
};

var sfInit = function() {
  ui = new StandaloneUI();
  config = new Config('badge');
  // Start at fast interval ‚Äî ramp up only on repeated no-matches
  config.defaultBrokerPollInterval = config.fastBrokerPollInterval;
  broker = new Broker(config);
  snowflake = new Snowflake(config, ui, broker);
  log('== snowflake proxy ==');
  sfUpdate();
  ui.initNATType();
  ui.setConsent(true);
};

// Commands from parent dashboard
window.addEventListener('message', function(e) {
  if (!e.data || !e.data._sfcmd) return;
  const cmd = e.data.cmd;
  if (cmd === 'start') {
    localStorage.setItem(LOCALSTORAGE_NAME, '1');
    sfUpdate();
  } else if (cmd === 'stop') {
    localStorage.removeItem(LOCALSTORAGE_NAME);
    if (snowflake) snowflake.disable();
    if (ui) ui.turnOff();
  } else if (cmd === 'retry') {
    if (ui && ui.popup) {
      ui.popup.retry.click();
    }
  }
});

window.onbeforeunload = function() {
  if (!silenceNotifications && snowflake && ui && ui.active) return Snowflake.MESSAGE.CONFIRMATION;
  return null;
};
window.onunload = function() { if (snowflake) snowflake.disable(); };
// DOMContentLoaded is earlier than window.onload (no wait for sub-resources)
// Fire 'ready' first so dashboard unblocks, then init engine
document.addEventListener('DOMContentLoaded', function() {
  window.parent.postMessage({_sf:1, type:'ready', ts:Date.now()}, '*');
  setTimeout(sfInit, 0); // yield ‚Äî let postMessage deliver before heavy init
});
`;

// ‚îÄ‚îÄ DOM stubs the Popup constructor queries ‚îÄ‚îÄ
const SF_STUBS=`
<input type="checkbox" id="enabled" style="display:none">
<button id="retry" style="display:none"></button>
<button id="consent" style="display:none"></button>
<div id="active" style="display:none"></div>
<span id="statustext" style="display:none"></span>
<span id="statusdesc" style="display:none"></span>
<img id="statusimg" style="display:none">
<div id="enabled-wrapper" style="display:none"></div>
<div id="run-in-background-wrapper" class="display-none" style="display:none">
  <input type="checkbox" id="run-in-background" style="display:none">
</div>
`;

function buildSrcdoc(){
  return `<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body>${SF_STUBS}<script>${SF_SRC}<\/script></body></html>`;
}

function launchFrame(){
  $('sf-frame').srcdoc=buildSrcdoc();
  addLog('sf','Proxy frame launched');
}

// ‚îÄ‚îÄ Messages from iframe ‚îÄ‚îÄ
window.addEventListener('message',function(e){
  if(!e.data||!e.data._sf)return;
  const d=e.data;
  _telWrite(d.type||'??',d);
  switch(d.type){
    case 'ready':
      S.sfReady=true;
      addLog('sf','Engine ready');
      if(S.enabled) sendCmd('start');
      break;
    case 'log':
      addLog('log',d.msg);
      break;
    case 'status':
      addLog('log','[status] '+d.msg);
      break;
    case 'statustext':
      setPillText(d.msg);
      break;
    case 'statusdesc':
      $('statusdesc-ui').textContent=d.msg||'';
      $('statusdesc-ui').className=d.error?'error':'';
      break;
    case 'retry':
      S.retryAvail=d.show;
      $('retry-btn').style.display=d.show?'inline-block':'none';
      if(d.show) addLog('warn','Bridge unreachable ‚Äî retry available');
      break;
    case 'enabled':
      setDot('dot-main', d.enabled?'ok':'');
      break;
    case 'active':
      if(d.active) setPhase('on'); else if(S.enabled) setPhase('wait');
      break;
    case 'checked':
      $('sw').checked=d.checked;
      break;
    case 'nat':
      S.nat=d.nat;
      $('s-nat').textContent=d.nat;
      addLog('sf','NAT: '+d.nat);
      break;
    case 'clients':
      S.clients=d.clients;
      $('s-clients').textContent=d.clients;
      if(d.clients>0){S.total++;$('s-total').textContent=S.total;saveSt();setPhase('on');}
      else if(S.enabled) setPhase('wait');
      break;
    case 'turnon':
      setPhase('on');
      $('s-clients').textContent=d.clients||0;
      break;
    case 'turnoff':
      if(S.enabled) setPhase('wait'); else setPhase('off');
      break;
    case 'missing':
      addLog('err','['+d.key+'] '+d.msg);
      setPhase('err', d.msg);
      break;
  }
  saveSt();
});

function sendCmd(cmd){ const f=$('sf-frame'); if(f.contentWindow) f.contentWindow.postMessage({_sfcmd:1,cmd},'*'); }

// ‚îÄ‚îÄ Toggle ‚îÄ‚îÄ
function onToggle(checked){
  S.enabled=checked;
  if(checked){
    S.startTs=Date.now(); S.uptimeSec=0;
    setPhase('wait','Connecting‚Ä¶');
    startUptime();
    // Send start regardless ‚Äî if engine not ready yet, it will start on 'ready' event
    sendCmd('start');
    if(!S.sfReady) addLog('sf','Queued ‚Äî engine initializing‚Ä¶');
  } else {
    sendCmd('stop');
    setPhase('off','Stopped');
    stopUptime();
    $('s-uptime').textContent='0s';
    $('ufill').style.width='0%';
    $('retry-btn').style.display='none';
    $('statusdesc-ui').textContent='';
  }
  saveSt();
}

// ‚îÄ‚îÄ Retry ‚îÄ‚îÄ
function onRetry(){
  addLog('sf','Retrying connection‚Ä¶');
  $('retry-btn').style.display='none';
  sendCmd('retry');
  setPhase('wait','Retrying‚Ä¶');
}

// ‚îÄ‚îÄ Phase / pill ‚îÄ‚îÄ
const PHASES={
  on:  {cls:'p-on',  dot:'ok',   txt:'Active ‚Äî Serving Clients'},
  wait:{cls:'p-wait',dot:'warn', txt:'Waiting for clients‚Ä¶'},
  off: {cls:'p-off', dot:'',     txt:'Stopped'},
  err: {cls:'p-err', dot:'err',  txt:'Error'}
};
function setPhase(phase, override){
  const p=PHASES[phase]||PHASES.off;
  $('pill').className='pill '+p.cls;
  $('pill-txt').textContent=override||p.txt;
  setDot('dot-main',p.dot);
}
function setPillText(t){ $('pill-txt').textContent=t; }
function setDot(id,s){const d=$(id);d.className='dot'+(s?' '+s:'');}

// ‚îÄ‚îÄ Uptime ‚îÄ‚îÄ
function startUptime(){
  stopUptime();
  uptimeTick=setInterval(()=>{
    S.uptimeSec++;
    const h=Math.floor(S.uptimeSec/3600),m=Math.floor(S.uptimeSec%3600/60),s=S.uptimeSec%60;
    const fmt=(n,u)=>n>0?n+u:'';
    $('hdr-uptime').textContent=[h,m,s].map(n=>String(n).padStart(2,'0')).join(':');
    $('s-uptime').textContent=h?h+'h '+m+'m':m?m+'m '+s+'s':s+'s';
    $('ufill').style.width=((S.uptimeSec%300)/300*100)+'%';
  },1000);
}
function stopUptime(){if(uptimeTick){clearInterval(uptimeTick);uptimeTick=null;}}

// ‚îÄ‚îÄ Log ‚îÄ‚îÄ
const logbox=$('logbox');
const rawbox=$('rawbox');
const LTYPES={log:'tl LOG',warn:'tw WRN',err:'te ERR',sf:'ts SFX',popup:'tp POP'};
// Telemetry state
const TEL={buf:[],seq:0,t0:Date.now(),prev:Date.now(),tab:'disp'};
// Type ‚Üí 2-char code
const TC={log:'LG',warn:'WN',err:'ER',sf:'SF',popup:'PP',
  ready:'RD',nat:'NT',clients:'CL',turnon:'ON',turnoff:'OF',
  missing:'MS',retry:'RT',status:'ST',statustext:'TX',statusdesc:'DC',
  enabled:'EN',active:'AC',checked:'CK'};
// Color class per type
const RC={err:'e',warn:'w',popup:'p',missing:'e',sf:'s',ready:'s',nat:'s'};
// XOR key ‚Äî makes payload unreadable without knowing the key
const XK=0x5F;
function _enc(raw){
  try{
    const s=typeof raw==='object'?JSON.stringify(raw):String(raw);
    const b=Array.from(s,(c)=>c.charCodeAt(0)^XK);
    return btoa(String.fromCharCode(...b));
  }catch(e){return '!ENC';}
}
function _telWrite(type,raw){
  const now=Date.now();
  const dt=now-TEL.t0, dd=now-TEL.prev;
  TEL.prev=now;
  const seq=(++TEL.seq).toString(16).padStart(4,'0');
  const tc=(TC[type]||'??');
  const key='T'+String(dt).padStart(7,'0')+'D'+String(dd).padStart(5,'0')+'|'+seq+'|'+tc;
  const val=_enc(raw);
  const e={key,val,type,raw,seq:TEL.seq};
  TEL.buf.push(e);
  if(TEL.buf.length>3000)TEL.buf.shift();
  if(TEL.tab==='raw')_renderRaw(e);
}
function _renderRaw(e){
  const row=document.createElement('div');
  row.className='rl';
  const vc=RC[e.type]||'';
  row.innerHTML='<span class="rk">'+e.key+'</span><span class="rv '+vc+'">'+e.val+'</span>';
  rawbox.appendChild(row);
  rawbox.scrollTop=rawbox.scrollHeight;
}
function setLogTab(t){
  TEL.tab=t;
  $('ltab-disp').classList.toggle('on',t==='disp');
  $('ltab-raw').classList.toggle('on',t==='raw');
  logbox.style.display=t==='disp'?'':'none';
  rawbox.style.display=t==='raw'?'':'none';
  $('rawfoot').style.display=t==='raw'?'':'none';
  if(t==='raw'&&rawbox.children.length===0){
    // first switch ‚Äî replay buffer
    TEL.buf.forEach(_renderRaw);
    rawbox.scrollTop=rawbox.scrollHeight;
  }
}
function exportRaw(){
  const hdr='# SF-TELEMETRY v2.4.0\n# T0='+new Date(TEL.t0).toISOString()+
    '\n# FMT: T{abs_ms}D{delta_ms}|{seq_hex}|{type_2c} {b64(xor0x5f(payload))}\n'+
    '# DECODE: b=atob(v); out=Array.from(b,c=>String.fromCharCode(c.charCodeAt(0)^0x5f)).join("")\n\n';
  const body=TEL.buf.map(e=>e.key+' '+e.val).join('\n');
  const bl=new Blob([hdr+body],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(bl);
  a.download='sf-tel-'+Date.now()+'.log';
  a.click();
  URL.revokeObjectURL(a.href);
  toast('Exported '+TEL.buf.length+' entries');
}
function addLog(type,msg){
  S.logN++;
  if(type==='err')S.errN++;
  const lc=$('log-count');
  lc.textContent=S.logN;
  lc.style.background=S.errN>0?'var(--err)':'var(--bg4)';
  lc.style.color=S.errN>0?'#fff':'';
  const [cls,lbl]=(LTYPES[type]||'tl LOG').split(' ');
  const ts=new Date().toTimeString().slice(0,8);
  const row=document.createElement('div');
  row.className='ll';
  row.innerHTML='<span class="lt '+cls+'">'+lbl+'</span><span class="lm">'+esc(String(msg))+'</span><span class="lts">'+ts+'</span>';
  logbox.appendChild(row);
  logbox.scrollTop=logbox.scrollHeight;
  _telWrite(type,msg);
}
function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

// ‚îÄ‚îÄ Persist ‚îÄ‚îÄ
const LSK='sf_v230';
function saveSt(){try{localStorage.setItem(LSK,JSON.stringify({total:S.total,nat:S.nat}));}catch(e){}}
function loadSt(){
  try{
    const d=JSON.parse(localStorage.getItem(LSK)||'{}');
    if(d.total){S.total=d.total;$('s-total').textContent=d.total;}
    if(d.nat){S.nat=d.nat;$('s-nat').textContent=d.nat;}
  }catch(e){}
}

// ‚îÄ‚îÄ UI ‚îÄ‚îÄ
$('cl-btn').onclick=()=>$('cl').classList.add('show');
function closeCL(){$('cl').classList.remove('show')}
$('clr-btn').onclick=()=>{
  logbox.innerHTML='';S.logN=0;S.errN=0;
  $('log-count').textContent='0';
  $('log-count').style.background='var(--bg4)';
  $('log-count').style.color='';
  rawbox.innerHTML='';TEL.buf=[];TEL.seq=0;TEL.t0=Date.now();TEL.prev=Date.now();
};
function toast(m){const t=$('toast');t.textContent=m;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),2000)}

// ‚îÄ‚îÄ Boot ‚îÄ‚îÄ
loadSt();
launchFrame();
addLog('sf','Dashboard v2.5.0 ‚Äî fast startup');
</script>
</body>
</html>